class Canv {
  static rootNode
  static btnListNode
  static canvas
  static ctx
  static funcs = new Map()
  static currentFuncID
  static setNode = (root) => {
    Canv.rootNode = root
    Canv.btnListNode = document.createElement('div')
    Canv.rootNode.appendChild(Canv.btnListNode)
  }
  static createBtn = (node, name, func) => {
    const btn = document.createElement('button')
    btn.innerText = name
    btn.addEventListener('click', func)
    node.appendChild(btn)
  }
  static addFunc = (funcs, root = document.getElementById('root')) => {
    Canv.setNode(root)
    for (const func of funcs) {
      const name = func.name
      Canv.funcs.set(name, func)
      Canv.createBtn(Canv.btnListNode, name, () => Canv.exeFunc(name))
    }
    Canv.defaultFunc(funcs[funcs.length - 1].name)
  }
  static defaultFunc = name => {
    name = location.search ? location.search.slice(1) : name
    Canv.exeFunc(name)
  }
  static setCanvSize = (x = window.innerWidth) => (y = 600) => {
    Canv.canvas.width = x; Canv.canvas.height = y;
  }
  static imgLoaded = []
  static waitResolveImgs = async () => await Promise.all(Canv.imgLoaded)
  static createImg = (path) => {
    const img = new Image()
    const promise = new Promise((resolve) => {
      img.src = path
      img.onload = () => resolve(true); console.log(`resolved: ${path}`);
    })
    Canv.imgLoaded.push(promise)
    return img
  }

  static exeFunc = (name) => {
    // Remove old canvas, function, imgPromises
    if (Canv.canvas) Canv.rootNode.removeChild(Canv.canvas)
    if (Canv.currentFuncID) {
      cancelAnimationFrame(Canv.currentFuncID)
      Canv.currentFuncID = 0
    }
    if (Canv.imgLoaded) Canv.imgLoaded = [];
    if (Canv.events) Canv.removeEvents()
    // Create canvas Html Element
    Canv.canvas = document.createElement('canvas')
    Canv.rootNode.appendChild(Canv.canvas)
    Canv.setCanvSize()()
    // Instanciate Context 
    Canv.ctx = Canv.canvas.getContext('2d')
    // Exec function
    Canv.funcs.get(name)(Canv.ctx)
  }
  static cancelLoop = () => {
    console.log(Canv.currentFuncID)
    if (Canv.currentFuncID) cancelAnimationFrame(Canv.currentFuncID)
  }
  // Wrapper func for loop animation
  static loop = (f) => {
    if (Canv.currentFuncID) cancelAnimationFrame(Canv.currentFuncID)
    const requestAnimFrame = (() =>
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      // window.mozRequestAnimationFrame ||
      // window.msRequestAnimationFrame ||
      (callback => window.setTimeout(callback, 1000 / 60))
    )()
    const repeat = () => {
      Canv.currentFuncID = requestAnimFrame(repeat)
      f()
    }
    Canv.currentFuncID = requestAnimFrame(repeat)
  }
  // Add event listner
  static events = []
  static registerEvent = (type, func, options = null) => {
    Canv.events.push([type, func])
    window.addEventListener(type, func, options)
  }
  static removeEvents = () => {
    for (let e of Canv.events) {
      window.removeEventListener(e[0], e[1])
    }
  }
  static drawBG = (color, clear = true) => {
    const clearBG = () => Canv.ctx.clearRect(0, 0, Canv.canvas.width, Canv.canvas.height)
    if (clear) clearBG()
    Canv.ctx.fillStyle = color
    Canv.ctx.fillRect(0, 0, Canv.canvas.width, Canv.canvas.height)
  }
  static drawArc = (x, y, r, color) => {
    Canv.ctx.beginPath()
    Canv.ctx.arc(x, y, r, 0, Math.PI * 2)
    Canv.ctx.closePath()
    Canv.ctx.fillStyle = color
    Canv.ctx.fill()
  }
  static randomRGBA = opacity => `rgba(${randomColor()},${randomColor()},${randomColor()}, ${opacity})`
  //
  static particle = O => size => col => [O.x, O.y, size, col]
  static moveParticle = O => size => col => V => {
    O.x += V.x
    O.y += V.y
    return [O.x, O.y, size, col]
  }
  static moveObj = O => Size => V => {
    O.x += V.x
    O.y += V.y
    return { x: O.x, y: O.y, w: Size.w, h: Size.h }
  }
  // Parse a json file generated by Aseprite
  //   Default: create each frame as a object, and generate a array with all frames.
  static parseAsperiteJSON = (data, toArray = false) => {
    const frames = data.frames
    let ary = []
    const frametoary = (frameObj) => [frameObj.x, frameObj.y, frameObj.w, frameObj.h]
    for (let key of Object.keys(frames)) {
      let eachFrame = frames[key].frame
      if (toArray) eachFrame = frametoary(eachFrame)
      ary.push(eachFrame)
    }
    return ary
  }
  static keydownHandler = funcs => e => {
    const isArrowKey = e => e.key.slice(0, 5) === 'Arrow'
    if (isArrowKey(e)) e.preventDefault()
    switch (e.key) {
      case 'ArrowRight':
        if (funcs.right) funcs.right(); break
      case 'ArrowLeft':
        if (funcs.left) funcs.left(); break
      case 'ArrowUp':
        if (funcs.up) funcs.up(); break
      case 'ArrowDown':
        if (funcs.down) funcs.down(); break
    }
  }
  static keyupHandler = func => e => func(e)
  //
  static drawImage = (source, inputFrame, outputImage = inputFrame) => {
    Canv.ctx.drawImage(
      source,
      ...[inputFrame.x, inputFrame.y, inputFrame.w, inputFrame.h],
      ...[outputImage.x, outputImage.y, outputImage.w, outputImage.h]
    )
  }
  // how to flip image: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale
  static flipImage = (image) => {
    const canv = document.createElement('canvas')
    const ctx = canv.getContext('2d')
    const newImage = new Image()
    canv.width = image.width
    canv.height = image.height
    ctx.scale(-1, 1)
    ctx.drawImage(image, -image.width, 0)
    newImage.src = canv.toDataURL()
    return newImage
  }
  static fitBackgroundScale = (imgOriginalWidth, maxScale) => {
    const cw = Canv.canvas.width
    const x = cw / imgOriginalWidth <= maxScale
      ? cw / imgOriginalWidth
      : maxScale
    const y = x
    Canv.ctx.scale(x, y)
  }
  // TODO: Aseprite の関数群として一つにまとめるか
  static frameCalc = (framesData, frameLength, speed, head, reverse = false) => tick => {
    const current = tick % (frameLength * speed)
    for (let i = 0; i < frameLength; i++) {
      const currentFrame = reverse ? head - i : head + i
      if (current < (i + 1) * speed) return framesData[currentFrame]
    }
  }
}

const randomColor = () => Math.random() * 255
export default Canv