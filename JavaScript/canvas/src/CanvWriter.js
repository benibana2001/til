class Canv {
  static canvas
  static ctx
  static funcs = new Map()
  static currentFuncID

  static addFunc = (funcs, root = document.getElementById('root')) => {
    setNode(root)

    for (const func of funcs) {
      const name = func.name
      Canv.funcs.set(name, func)
      createButton(btnListNode, name, () => Canv.exeFunc(name))
    }
    Canv.defaultFunc(funcs[funcs.length - 1].name)
  }

  static defaultFunc = name => {
    name = location.search ? location.search.slice(1) : name
    Canv.exeFunc(name)
  }

  static setCanvSize = (x = window.innerWidth) => (y = 600) => setCanvSize(Canv.canvas)(x)(y)

  static waitResolveImgs = async () => await waitResolveImgs()
  static createImg = (path) => createImg(path)

  static exeFunc = (name) => {
    // Remove old canvas, function, imgPromises
    if (Canv.canvas) rootNode.removeChild(Canv.canvas)
    if (Canv.currentFuncID) {
      cancelAnimationFrame(Canv.currentFuncID)
      Canv.currentFuncID = 0
    }

    clearImgLoaded()

    if (Canv.events) Canv.removeEvents()

    // Create canvas Html Element
    Canv.canvas = document.createElement('canvas')
    rootNode.appendChild(Canv.canvas)
    setCanvSize(Canv.canvas)()()

    // Instanciate Context 
    Canv.ctx = Canv.canvas.getContext('2d')

    // Exec function
    Canv.funcs.get(name)(Canv.ctx)
  }

  static cancelLoop = () => {
    console.log(Canv.currentFuncID)
    if (Canv.currentFuncID) cancelAnimationFrame(Canv.currentFuncID)
  }
  // Wrapper func for loop animation
  static loop = (f) => {
    if (Canv.currentFuncID) cancelAnimationFrame(Canv.currentFuncID)
    const requestAnimFrame = (() =>
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      (callback => window.setTimeout(callback, 1000 / 60))
    )()
    const repeat = () => {
      Canv.currentFuncID = requestAnimFrame(repeat)
      f()
    }
    Canv.currentFuncID = requestAnimFrame(repeat)
  }

  // Add event listner
  static events = []
  static registerEvent = (type, func, options = null) => {
    Canv.events.push([type, func])
    window.addEventListener(type, func, options)
  }
  static removeEvents = () => {
    for (let e of Canv.events) {
      window.removeEventListener(e[0], e[1])
    }
  }

  static drawBG = (color, clear = true) => drawBG(Canv.canvas, Canv.ctx, color, clear)
  static drawArc = (x, y, r, color) => drawArc(Canv.ctx, x, y, r, color)

  static particle = O => size => col => particle(O)(size)(col)
  static moveParticle = O => size => col => V => moveParticle(O)(size)(col)(V)
  static moveObj = O => Size => V => moveObj(O)(Size)(V)

  static randomRGBA = opacity => randomRGBA(opacity)

  // Parse a json file generated by Aseprite
  //   Default: create each frame as a object, and generate a array with all frames.
  static parseAsperiteJSON = (data, toArray = false) => parseAsperiteJSON(data, toArray)

  static arrowKeydownHandler = funcs => e => arrowKeydownHandler(funcs)(e)

  static keyupHandler = func => e => func(e)

  static arrowKeyUpHandler = funcs => e => arrowKeyUpHandler(funcs)(e)
  //
  static drawImage = (source, inputFrame, outputImage = inputFrame) => {
    Canv.ctx.drawImage(
      source,
      ...[inputFrame.x, inputFrame.y, inputFrame.w, inputFrame.h],
      ...[outputImage.x, outputImage.y, outputImage.w, outputImage.h]
    )
  }

  // how to flip image: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale
  static flipImage = image => flipImage(image)

  static fitBackgroundScale = (imgOriginalWidth, maxScale) => fitBackgroundScale(Canv.canvas, Canv.ctx, imgOriginalWidth, maxScale)

  static frameCalc = (framesData, frameLength, speed, head, reverse = false) => tick => frameCalc(framesData, frameLength, speed, head, reverse)(tick)

  static deviceTrigger = () => deviceTrigger()
  static getTouchPosition = e => getTouchPosition(e)
}

let rootNode = null
let btnListNode = null

function setNode (root) {
  rootNode = root
  btnListNode = document.createElement('div')
  rootNode.appendChild(btnListNode)
}

function createButton(node, name, func) {
  const btn = document.createElement('button')
  btn.innerText = name
  btn.addEventListener('click', func)
  node.appendChild(btn)
}

let imgLoaded = []
const clearImgLoaded = () => {
  if (imgLoaded) imgLoaded = []
}
async function waitResolveImgs() {
  await Promise.all(imgLoaded)
}
function createImg(path) {
  const img = new Image()
  const promise = new Promise((resolve) => {
    img.src = path
    img.onload = () => resolve(true); console.log(`resolved: ${path}`);
  })
  imgLoaded.push(promise)
  return img
}

const setCanvSize = canvas => (x = window.innerWidth) => (y = 600) => {

Canv.canvas.width = x; Canv.canvas.height = y;
}

function drawBG(canvas, context, color, clear = true) {
  const clearBG = () => context.clearRect(0, 0, canvas.width, canvas.height)
  if (clear) clearBG()
  context.fillStyle = color
  context.fillRect(0, 0, canvas.width, canvas.height)
}

function drawArc(context, x, y, r, color) {
  context.beginPath()
  context.arc(x, y, r, 0, Math.PI * 2)
  context.closePath()
  context.fillStyle = color
  context.fill()
}

function fitBackgroundScale(canvas, context, imgOriginalWidth, maxScale) {
  const cw = canvas.width
  const x = cw / imgOriginalWidth <= maxScale
    ? cw / imgOriginalWidth
    : maxScale
  const y = x
  context.scale(x, y)
  return [x, y]
}

const randomColor = () => Math.random() * 255
const randomRGBA = opacity => `rgba(${randomColor()},${randomColor()},${randomColor()}, ${opacity})`

const particle = O => size => col => [O.x, O.y, size, col]
const moveParticle = O => size => col => V => {
  O.x += V.x
  O.y += V.y
  return [O.x, O.y, size, col]
}
const moveObj = O => Size => V => {
  O.x += V.x
  O.y += V.y
  return { x: O.x, y: O.y, w: Size.w, h: Size.h }
}

function parseAsperiteJSON(data, toArray = false) {
  const frames = data.frames
  let ary = []
  const frametoary = (frameObj) => [frameObj.x, frameObj.y, frameObj.w, frameObj.h]
  for (let key of Object.keys(frames)) {
    let eachFrame = frames[key].frame
    if (toArray) eachFrame = frametoary(eachFrame)
    ary.push(eachFrame)
  }
  return ary
}

// TODO: Aseprite の関数群として一つにまとめるか
const frameCalc = (framesData, frameLength, speed, head, reverse = false) => tick => {
  const current = tick % (frameLength * speed)
  for (let i = 0; i < frameLength; i++) {
    const currentFrame = reverse ? head - i : head + i
    if (current < (i + 1) * speed) return framesData[currentFrame]
  }
}

const arrowKeydownHandler = funcs => e => {
  const isArrowKey = e => e.key.slice(0, 5) === 'Arrow'
  if (isArrowKey(e)) e.preventDefault()
  switch (e.key) {
    case 'ArrowRight':
      if (funcs.right) funcs.right(); break
    case 'ArrowLeft':
      if (funcs.left) funcs.left(); break
    case 'ArrowUp':
      if (funcs.up) funcs.up(); break
    case 'ArrowDown':
      if (funcs.down) funcs.down(); break
  }
}

const arrowKeyUpHandler = funcs => e => {
  const isArrowKey = e => e.key.slice(0, 5) === 'Arrow'
  if (isArrowKey(e)) e.preventDefault()
  switch (e.key) {
    case 'ArrowRight':
      if (funcs.right) funcs.right(); break
    case 'ArrowLeft':
      if (funcs.left) funcs.left(); break
    case 'ArrowUp':
      if (funcs.up) funcs.up(); break
    case 'ArrowDown':
      if (funcs.down) funcs.down(); break
  }
}

function flipImage(image) {
  const canv = document.createElement('canvas')
  const ctx = canv.getContext('2d')
  const newImage = new Image()
  canv.width = image.width
  canv.height = image.height
  ctx.scale(-1, 1)
  ctx.drawImage(image, -image.width, 0)
  newImage.src = canv.toDataURL()
  return newImage
}

const deviceTrigger = () => ({
  start: isTouchDevice ? 'touchstart' : 'mousedown',
  end: isTouchDevice ? 'touchend' : 'mouseup'
})

const getTouchPosition = e => ({
  x: isTouchDevice ? e.changedTouches[0].pageX : e.pageX,
  y: isTouchDevice ? e.changedTouches[0].pageY : e.pageY
})

const isTouchDevice = 'ontouchend' in document


// Device check
// 
// not using
// const isSmartPhone = navigator.userAgent.match(/iPhone|Android.+Mobile/) ? true : false
//
//
export default Canv